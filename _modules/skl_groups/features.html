

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>skl_groups.features &mdash; skl-groups 0.1.0-dev documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="skl-groups 0.1.0-dev documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../index.html" class="fa fa-home"> skl-groups</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../who.html">Who this package is for</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#release-versions">Release versions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#development-version">Development version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#flann">FLANN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#accelerated-version">Accelerated version</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Quick tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial.html#motivation">Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial.html#feature-representation">Feature representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial.html#means">Means</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial.html#bag-of-words">Bag of Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial.html#divergences">Divergences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial.html#l2-density-transformer">L2 density transformer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">API reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference.html#features-representation">Features representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference.html#preprocessing">Preprocessing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference.html#summaries">Summaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference.html#divergences">Divergences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference.html#kernel-utilities">Kernel utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../todo.html">Planned improvements</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">skl-groups</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>skl_groups.features</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <h1>Source code for skl_groups.features</h1><pre>
from __future__ import division, print_function

from copy import deepcopy
import warnings

import numpy as np
from sklearn.externals.six import iteritems, string_types
from sklearn.externals.six.moves import xrange

from .utils import as_integer_type


<div class="viewcode-block" id="Features"><a class="viewcode-back" href="../../skl_groups/skl_groups.features.Features.html#skl_groups.features.Features">[docs]</a>class Features(object):
    &#x27;&#x27;&#x27;
    A wrapper class for storing bags of features. (A *bag* is a set of feature
    vectors corresponding to a single &quot;object.&quot;)

    Supports storing data in two major ways:

    - As a list of pointers to a numpy array per bag. This is the default,
      because it usually doesn&#x27;t require copying all of your data. Note that
      the sub-arrays are not enforced to be row-major or even contiguous.

    - As a single big row-major array. This lets you do certain things more
      easily (e.g. run PCA).

    The main usage API is the same for both versions; you can distinguish them
    with the `stacked` property, and convert from pointers to stacked with the
    `make_stacked()` method.

    Supports the following operations:

    * ``len(features)`` gives the number of bags.
    * ``for bag in features:`` loops over bags.
    * ``features[4]`` gives the fifth bag.
    * ``features[[4, 8, 7]]`` makes a new Features object with only the \
       passed indices, preserving metadata.
    * ``feats1 == feats2`` checks that all of the features `and metadata` are \
      the same.
    * ``feats1 + feats2`` concatenates the two Features objects. Metadata is \
      preserved if both features have that key, thrown out if not.


    Parameters
    ----------
    bags : list of numpy arrays, single array, or Features object
        The feature data. If a list of numpy arrays, should be one array per 
        bag, each of shape [n_pts, dim], where dim is consistent between bags
        but n_pts need not be (though it cannot ever be 0). If a single numpy
        array, it should be of shape [sum(n_pts), dim] and contain the features
        from the first bag, then the next bag, .... In this case you must also
        pass n_pts. If a Features object, &quot;copies&quot; it (but only actually copies
        any data if ``copy=True``).

    n_pts : array-like of positive integers, only if bags is a single array
        If bags is passed as a single array, a list of positive integers
        defining the size of each bag.

    stack : boolean, optional, default False
        If true, stack the features. Otherwise, only stack them if a stacked
        array of features is passed in.

    copy : boolean, optional, default False
        If true, always make a copy of the data (so that direct modifications)
        don&#x27;t modify the original arrays. If false, make a copy only if
        necessary (i.e. stack=True for an unstacked argument).

    bare : boolean, optional, default False
        If true, and ``bags`` is a Features instance, don&#x27;t include its
        metadata.

    any other keyword argument : array-like with first dimension num_bags
        Metadata for each bag. Just stored along with the features, nothing
        in particular done with it. (If ``bags`` is a Features instance, its
        metadata is merged with any keyword arguments, with keywords taking
        precedence.)


    Attributes
    ----------
    features : list of arrays of shape ``[n_pts[i], dim]``
        A list of the contained features.
        If ``stacked``, each array is a slice of ``stacked_features``.

    stacked : boolean
        Whether the features are stacked.

    stacked_features : array of shape ``[sum(n_pts), dim]``
        All of the features, concatenated together. Only present if ``stacked``.

    n_pts : integer array of shape ``[len(self)]``
        The number of points in each bag.

    meta : dictionary mapping strings to arrays of shape ``[len(self)]``
        The stored metadata. ``meta[&#x27;foo&#x27;]`` is also accessible as ``self.foo``.
    &#x27;&#x27;&#x27;

<div class="viewcode-block" id="Features.__init__"><a class="viewcode-back" href="../../skl_groups/skl_groups.features.Features.html#skl_groups.features.Features.__init__">[docs]</a>    def __init__(self, bags, n_pts=None, stack=False, copy=False, bare=False,
                 **meta):
        if isinstance(bags, Features):
            if n_pts is not None:
                raise TypeError(&quot;can&#x27;t pass n_pts if copying a Features object&quot;)

            oth = bags
            if oth.stacked:
                bags = oth.stacked_features
                n_pts = oth.n_pts
            else:
                bags = oth.features
                n_pts = None
            if not bare:
                for k, v in iteritems(oth.meta):
                    meta.setdefault(k, v)


        if isinstance(bags, np.ndarray) and bags.ndim == 2:
            if n_pts is None:
                raise TypeError(&quot;must pass n_pts if passing stacked array of &quot;
                                &quot;features&quot;)

            n_pts = np.asarray(n_pts)
            if n_pts.ndim != 1:
                raise TypeError(&quot;n_pts must be 1-dimensional&quot;)
            if n_pts.size == 0:
                raise TypeError(&quot;must have at least one bag&quot;)
            if np.any(n_pts &lt;= 0):
                raise TypeError(&quot;n_pts must all be positive&quot;)
            try:
                n_pts = as_integer_type(n_pts)
            except ValueError:
                raise TypeError(&quot;n_pts must be an array of integers.&quot;)

            bags = np.array(bags, order=&#x27;C&#x27;, copy=copy)
            if bags.ndim != 2 or bags.shape[0] != np.sum(n_pts):
                raise TypeError(&quot;bags must have shape sum(n_pts) x dim&quot;)
            if bags.shape[1] == 0:
                raise TypeError(&quot;bags must have dimension &gt; 0&quot;)
            dim = bags.shape[1]

            self.stacked = True
            self.n_pts = n_pts
            self.stacked_features = bags
            self._boundaries = bounds = np.r_[0, np.cumsum(n_pts)]

            self.features = np.empty(len(n_pts), object)
            self.features[:] = [bags[bounds[i-1]:bounds[i]]
                                for i in xrange(1, len(bounds))]

        else:
            if n_pts is not None:
                raise TypeError(&quot;n_pts should only be passed if bags is a &quot;
                                &quot;single stacked array&quot;)

            dim = None
            dtype = None
            new_bags = np.empty(len(bags), dtype=object)
            n_pts = np.empty(len(bags), dtype=int)
            for i, bag in enumerate(bags):
                a = np.array(bag, copy=copy)

                if a.ndim == 1:
                    a = a[None, :]
                if a.ndim != 2:
                    raise TypeError(&quot;bag {} not two-dimensional&quot;.format(i))

                if dim is None:
                    dim = a.shape[1]
                elif a.shape[1] != dim:
                    msg = &quot;bags&#x27; second dimension must be consistent: &quot; \
                          &quot;{} is {}, expected {}&quot;
                    raise TypeError(msg.format(i, a.shape[1], dim))

                if dtype is None:
                    dtype = a.dtype
                    if dtype.kind not in &#x27;fiu&#x27;:
                        msg = &quot;can&#x27;t handle features of type {}&quot;
                        raise TypeError(msg.format(a.dtype.name))
                elif a.dtype != dtype:
                    msg = &quot;bags&#x27; dtype is inconsistent: {} is {}, expected {}&quot;
                    raise TypeError(msg.format(i, a.dtype.name, dtype.name))

                if a.shape[0] == 0:
                    raise TypeError(&quot;bag {} has no points&quot;.format(i))

                new_bags[i] = a
                n_pts[i] = a.shape[0]

            self.stacked = False
            self.n_pts = n_pts
            self.features = new_bags
            try:
                del self._boundaries
            except AttributeError:
                pass
            try:
                del self.stacked_features
            except AttributeError:
                pass

            if stack:
                self.make_stacked()

        # handle metadata
        self.meta = {}
        for name, val in iteritems(meta):
            if len(val) != len(n_pts):
                msg = &quot;Have {} bags but {} values for {}&quot;
                raise ValueError(msg.format(len(n_pts), len(val), name))

            val = np.array(val, copy=copy)
            self.meta[name] = val
            if hasattr(self, name):
                msg = &quot;Features already has an attribute named &#x27;{}&#x27;; won&#x27;t &quot; \
                      &quot;be accessible as an attribute&quot;
                warnings.warn(msg.format(name))
            else:
                setattr(self, name, val)
</div>
<div class="viewcode-block" id="Features.make_stacked"><a class="viewcode-back" href="../../skl_groups/skl_groups.features.Features.html#skl_groups.features.Features.make_stacked">[docs]</a>    def make_stacked(self):
        &quot;If unstacked, convert to stacked. If stacked, do nothing.&quot;
        if self.stacked:
            return

        self._boundaries = bounds = np.r_[0, np.cumsum(self.n_pts)]
        self.stacked_features = stacked = np.vstack(self.features)
        self.features = [stacked[bounds[i-1]:bounds[i]]
                         for i in xrange(1, len(bounds))]
        self.stacked = True

    ############################################################################
    ## Properties to get at basic metadata
</div>
    @property
<div class="viewcode-block" id="Features.total_points"><a class="viewcode-back" href="../../skl_groups/skl_groups.features.Features.html#skl_groups.features.Features.total_points">[docs]</a>    def total_points(self):
        &quot;The total number of points in all bags.&quot;
        return self.n_pts.sum()
</div>
    @property
<div class="viewcode-block" id="Features.dim"><a class="viewcode-back" href="../../skl_groups/skl_groups.features.Features.html#skl_groups.features.Features.dim">[docs]</a>    def dim(self):
        &quot;The dimensionality of the features.&quot;
        return self.features[0].shape[1]
</div>
    @property
<div class="viewcode-block" id="Features.dtype"><a class="viewcode-back" href="../../skl_groups/skl_groups.features.Features.html#skl_groups.features.Features.dtype">[docs]</a>    def dtype(self):
        &quot;The data type of the feature vectors.&quot;
        return self.features[0].dtype

    ############################################################################
    ## Copying / pickling utilities
</div>
<div class="viewcode-block" id="Features.copy"><a class="viewcode-back" href="../../skl_groups/skl_groups.features.Features.html#skl_groups.features.Features.copy">[docs]</a>    def copy(self, stack=False, copy_meta=False, memo=None):
        &#x27;&#x27;&#x27;
        Copies the Feature object. Makes a copy of the features array.

        Parameters
        ----------
        stack : boolean, optional, default False
            Whether to stack the copy if this one is unstacked.

        copy_meta : boolean, optional, default False
            Also copy the metadata. If False, metadata in both points to the
            same object.
        &#x27;&#x27;&#x27;
        if self.stacked:
            fs = deepcopy(self.stacked_features, memo)
            n_pts = self.n_pts.copy()
        elif stack:
            fs = np.vstack(self.features)
            n_pts = self.n_pts.copy()
        else:
            fs = deepcopy(self.features, memo)
            n_pts = None

        meta = deepcopy(self.meta, memo) if copy_meta else self.meta
        return Features(fs, n_pts, copy=False, **meta)
</div>
    def __copy__(self):
        return self.copy(stack=False, copy_meta=False)

    def __deepcopy__(self, memo=None):
        return self.copy(stack=False, copy_meta=True, memo=memo)

    def __getstate__(self):
        if self.stacked:
            return (self.stacked_features, self.n_pts, self.meta)
        else:
            return (self.features, None, self.meta)

    def __setstate__(self, state):
        feats, n_pts, meta = state
        self.__init__(feats, n_pts, **meta)

    ############################################################################ 
    ## General magic methods for basic behavior

    __hash__ = None

    def __eq__(self, oth):
        if self is oth:
            return True
        elif isinstance(oth, Features):
            return (len(self) == len(oth) and
                    set(self.meta) == set(oth.meta) and
                    all(np.all(self_b == oth_b)
                        for self_b, oth_b in zip(self, oth)) and
                    all(np.all(self.meta[k] == oth.meta[k])
                        for k in self.meta))
        elif self.meta:
            return False
        else:
            return (len(self) == len(oth) and 
                    all(np.all(self_b == oth_b)
                        for self_b, oth_b in zip(self, oth)))

    def __ne__(self, oth):
        return not (self == oth)

    def __repr__(self):
        s = &#x27;&lt;Features: {:,} bags with {} {}-dimensional points ({:,} total)&gt;&#x27;
        min_p = self.n_pts.min()
        max_p = self.n_pts.max()
        if min_p == max_p:
            pts = &quot;{:,}&quot;.format(min_p)
        else:
            pts = &#x27;{:,} to {:,}&#x27;.format(min_p, max_p)
        return s.format(len(self), pts, self.dim, self.total_points)

    def __len__(self):
        return self.n_pts.size

    def __iter__(self):
        return iter(self.features)

    def __getitem__(self, key):
        if (isinstance(key, string_types) or
                (isinstance(key, tuple) and
                 any(isinstance(x, string_types) for x in key))):
            msg = &quot;Features indexing only subsets rows, but got {!r}&quot;
            raise TypeError(msg.format(key))

        if np.isscalar(key):
            return self.features[key]
        else:
            return type(self)(self.features[key], copy=False, stack=False,
                              **{k: v[key] for k, v in iteritems(self.meta)})

    def __add__(self, oth):
        if isinstance(oth, Features):
            meta = {k: np.r_[self.meta[k], oth.meta[k]]
                    for k in self.meta if k in oth.meta}
            oth_features = oth.features
        elif isinstance(oth, list):
            meta = {}
            oth_features = np.empty(len(oth), object)
            oth_features[:] = oth
        else:
            return NotImplemented

        return Features(np.r_[self.features, oth_features],
                        stack=False, copy=True, **meta)

    def __radd__(self, oth):
        if isinstance(oth, list):
            oth_features = np.empty(len(oth), object)
            oth_features[:] = oth
        else:
            return NotImplemented
        return Features(np.r_[oth_features, self.features],
                        stack=False, copy=True)

    ############################################################################
    ## Others

<div class="viewcode-block" id="Features.bare"><a class="viewcode-back" href="../../skl_groups/skl_groups.features.Features.html#skl_groups.features.Features.bare">[docs]</a>    def bare(self):
        &quot;Make a Features object with no metadata; points to the same features.&quot;
        if not self.meta:
            return self
        elif self.stacked:
            return Features(self.stacked_features, self.n_pts, copy=False)
        else:
            return Features(self.features, copy=False)</div></div>
</pre>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Dougal J. Sutherland.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.1.0-dev',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>